"use strict";(globalThis.webpackChunkcortex_h1=globalThis.webpackChunkcortex_h1||[]).push([[9678],{3894:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"labs/lab-7-lipm-locomotion","title":"Lab 7: Humanoid Locomotion with LIPM","description":"Objective","source":"@site/docs/labs/lab-7-lipm-locomotion.md","sourceDirName":"labs","slug":"/labs/lab-7-lipm-locomotion","permalink":"/Cortex-H1/docs/labs/lab-7-lipm-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/labs/lab-7-lipm-locomotion.md","tags":[],"version":"current","frontMatter":{"id":"lab-7-lipm-locomotion","title":"Lab 7: Humanoid Locomotion with LIPM","sidebar_label":"Lab 7: LIPM Locomotion"},"sidebar":"textbookSidebar","previous":{"title":"Lab 6: LLM Planner","permalink":"/Cortex-H1/docs/labs/lab-6-llm-planner"},"next":{"title":"Labs Introduction","permalink":"/Cortex-H1/docs/labs/lab-intro"}}');var a=s(4848),i=s(8453);const l={id:"lab-7-lipm-locomotion",title:"Lab 7: Humanoid Locomotion with LIPM",sidebar_label:"Lab 7: LIPM Locomotion"},r="Lab 7: Humanoid Locomotion with the Linear Inverted Pendulum Model (LIPM)",o={},c=[{value:"Objective",id:"objective",level:2},{value:"Theoretical Background",id:"theoretical-background",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step-by-Step Instructions",id:"step-by-step-instructions",level:2},{value:"Step 1: Create a New Python Package for Locomotion Planning",id:"step-1-create-a-new-python-package-for-locomotion-planning",level:3},{value:"Step 2: Implement the LIPM Planner",id:"step-2-implement-the-lipm-planner",level:3},{value:"Step 3: Create an Executable Script to Run the Planner",id:"step-3-create-an-executable-script-to-run-the-planner",level:3},{value:"Step 4: Update <code>setup.py</code> and <code>package.xml</code> for <code>my_humanoid_planner</code>",id:"step-4-update-setuppy-and-packagexml-for-my_humanoid_planner",level:3},{value:"Step 5: Build Your Package and Run the Planner",id:"step-5-build-your-package-and-run-the-planner",level:3},{value:"Verification",id:"verification",level:2},{value:"Challenge Questions",id:"challenge-questions",level:2}];function h(e){const n={annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"lab-7-humanoid-locomotion-with-the-linear-inverted-pendulum-model-lipm",children:"Lab 7: Humanoid Locomotion with the Linear Inverted Pendulum Model (LIPM)"})}),"\n",(0,a.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,a.jsxs)(n.p,{children:["This lab delves into the core of stable bipedal locomotion for humanoid robots using the ",(0,a.jsx)(n.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),". You will implement a basic LIPM planner in Python to generate stable Center of Mass (CoM) trajectories for a single step, laying the groundwork for more complex walking gaits."]}),"\n",(0,a.jsx)(n.h2,{id:"theoretical-background",children:"Theoretical Background"}),"\n",(0,a.jsxs)(n.p,{children:["As discussed in ",(0,a.jsx)(n.strong,{children:"Chapter 9: Humanoid Robotics"}),", stable bipedal walking is fundamentally about controlling the robot's ",(0,a.jsx)(n.strong,{children:"Center of Mass (CoM)"})," relative to its ",(0,a.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),". The LIPM simplifies the robot's dynamics, allowing us to generate CoM trajectories that ensure the ZMP remains within the support polygon, thus preventing the robot from falling."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"LIPM"}),": A simplified model where the robot's mass is concentrated at a single point (CoM) and its height above the ground (",(0,a.jsx)(n.code,{children:"z_c"}),") is constant."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ZMP"}),": The point on the ground where the net moment of all forces is zero. It must stay within the support polygon for stability."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CoM Trajectory"}),": The path the robot's CoM follows during walking."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The equation of motion for the LIPM in the x-direction is:\n",(0,a.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Unexpected character: '\x10' at position 1: \x10\u0332c\\ddot{x} - \\om\u2026",style:{color:"#cc0000"},children:"\x10c\\ddot{x} - \\omega^2 x = 0"}),"\nwhere ",(0,a.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Unexpected character: '\x10' at position 1: \x10\u0332c\\omega = \x10c\\sq\u2026",style:{color:"#cc0000"},children:"\x10c\\omega = \x10c\\sqrt{g/z_c}"})," is the natural frequency, ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"g"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"g"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"})]})})]})," is gravity, and ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"z"}),(0,a.jsx)(n.mi,{children:"c"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"z_c"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.1514em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.044em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mathnormal mtight",children:"c"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," is the constant CoM height.\nThe general solution for the CoM position ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"x"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"t"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"x(t)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," and velocity ",(0,a.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Unexpected character: '\x10' at position 1: \x10\u0332c\\dot{x}(t)",style:{color:"#cc0000"},children:"\x10c\\dot{x}(t)"})," is:\n",(0,a.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Unexpected character: '\x10' at position 12: x(t) = C_1 \x10\u0332c\\cosh(\\omega t\u2026",style:{color:"#cc0000"},children:"x(t) = C_1 \x10c\\cosh(\\omega t) + C_2 \x10c\\sinh(\\omega t)"}),"\n",(0,a.jsx)(n.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Unexpected character: '\x10' at position 1: \x10\u0332c\\dot{x}(t) = \x10\u2026",style:{color:"#cc0000"},children:"\x10c\\dot{x}(t) = \x10c\\omega (C_1 \x10c\\sinh(\\omega t) + C_2 \x10c\\cosh(\\omega t))"}),"\n",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"C"}),(0,a.jsx)(n.mn,{children:"1"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"C_1"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.3011em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"1"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," and ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mi,{children:"C"}),(0,a.jsx)(n.mn,{children:"2"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"C_2"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.3011em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,a.jsx)(n.span,{})})})]})})]})]})})]})," are constants determined by initial conditions."]}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Python 3.10+"}),": With ",(0,a.jsx)(n.code,{children:"numpy"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ROS 2 Humble Development Environment"}),": (for general setup, though this lab is Python-only)."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-instructions",children:"Step-by-Step Instructions"}),"\n",(0,a.jsx)(n.h3,{id:"step-1-create-a-new-python-package-for-locomotion-planning",children:"Step 1: Create a New Python Package for Locomotion Planning"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python my_humanoid_planner\ncd my_humanoid_planner\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-2-implement-the-lipm-planner",children:"Step 2: Implement the LIPM Planner"}),"\n",(0,a.jsxs)(n.p,{children:["Create a file named ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/my_humanoid_planner/lipm_planner.py"})," and add the following Python code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass LIPMPlanner:\n    """\n    Implements a basic Linear Inverted Pendulum Model (LIPM) planner\n    to generate Center of Mass (CoM) trajectories for stable walking.\n    """\n    def __init__(self, com_height_z, gravity=9.81):\n        """\n        Initializes the LIPM planner.\n        Args:\n            com_height_z (float): The constant height of the Center of Mass (z_c) in meters.\n            gravity (float): Acceleration due to gravity (g) in m/s^2.\n        """\n        if com_height_z <= 0:\n            raise ValueError("CoM height (z_c) must be positive.")\n        self.z_c = com_height_z\n        self.g = gravity\n        self.omega = np.sqrt(self.g / self.z_c) # Natural frequency of the LIPM\n\n    def calculate_com_trajectory(self, x0, vx0, t_start, t_end, num_points=100):\n        """\n        Calculates the CoM trajectory (position and velocity) given initial conditions\n        and a time interval.\n        Args:\n            x0 (float): Initial CoM position in x-direction.\n            vx0 (float): Initial CoM velocity in x-direction.\n            t_start (float): Start time of the trajectory.\n            t_end (float): End time of the trajectory.\n            num_points (int): Number of points to generate for the trajectory.\n        Returns:\n            tuple: (times, x_trajectory, vx_trajectory)\n        """\n        if t_end <= t_start:\n            raise ValueError("t_end must be greater than t_start.")\n\n        # Constants C1 and C2 from initial conditions (at t=t_start)\n        # x0 = C1 cosh(omega * t_start) + C2 sinh(omega * t_start)\n        # vx0 = omega (C1 sinh(omega * t_start) + C2 cosh(omega * t_start))\n        \n        # Solving for C1 and C2\n        cosh_t0 = np.cosh(self.omega * t_start)\n        sinh_t0 = np.sinh(self.omega * t_start)\n        \n        det = self.omega * (cosh_t0**2 - sinh_t0**2) # Should be omega\n        \n        C1 = (vx0 * cosh_t0 - x0 * self.omega * sinh_t0) / self.omega\n        C2 = (x0 * self.omega * cosh_t0 - vx0 * sinh_t0) / self.omega\n        \n        times = np.linspace(t_start, t_end, num_points)\n        x_trajectory = C1 * np.cosh(self.omega * times) + C2 * np.sinh(self.omega * times)\n        vx_trajectory = self.omega * (C1 * np.sinh(self.omega * times) + C2 * np.cosh(self.omega * times))\n\n        return times, x_trajectory, vx_trajectory\n\n    def generate_single_step_com(self, initial_com_x, initial_com_vx, step_duration, desired_zmp_x=0.0):\n        """\n        Generates a CoM trajectory for a single step assuming a constant ZMP.\n        Args:\n            initial_com_x (float): CoM x-position at the start of the step.\n            initial_com_vx (float): CoM x-velocity at the start of the step.\n            step_duration (float): Duration of the single step.\n            desired_zmp_x (float): Desired ZMP position during this step (relative to the support foot).\n        Returns:\n            tuple: (times, x_trajectory, vx_trajectory, final_com_x, final_com_vx)\n        """\n        # Adjust initial CoM relative to desired ZMP\n        x0_rel_zmp = initial_com_x - desired_zmp_x\n        vx0_rel_zmp = initial_com_vx\n\n        # Calculate C1 and C2 for the relative motion\n        cosh_t0 = np.cosh(self.omega * 0) # t_start is 0 for simplicity here\n        sinh_t0 = np.sinh(self.omega * 0)\n        \n        C1 = (vx0_rel_zmp * cosh_t0 - x0_rel_zmp * self.omega * sinh_t0) / self.omega\n        C2 = (x0_rel_zmp * self.omega * cosh_t0 - vx0_rel_zmp * sinh_t0) / self.omega\n        \n        times = np.linspace(0, step_duration, 100)\n        x_trajectory_rel_zmp = C1 * np.cosh(self.omega * times) + C2 * np.sinh(self.omega * times)\n        vx_trajectory_rel_zmp = self.omega * (C1 * np.sinh(self.omega * times) + C2 * np.cosh(self.omega * times))\n        \n        # Convert back to absolute CoM position\n        x_trajectory = x_trajectory_rel_zmp + desired_zmp_x\n        vx_trajectory = vx_trajectory_rel_zmp\n\n        final_com_x = x_trajectory[-1]\n        final_com_vx = vx_trajectory[-1]\n\n        return times, x_trajectory, vx_trajectory, final_com_x, final_com_vx\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"step-3-create-an-executable-script-to-run-the-planner",children:"Step 3: Create an Executable Script to Run the Planner"}),"\n",(0,a.jsxs)(n.p,{children:["Create a file named ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/my_humanoid_planner/run_lipm_planner.py"})," and add the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import matplotlib.pyplot as plt\nfrom my_humanoid_planner.lipm_planner import LIPMPlanner\n\ndef main():\n    # Initialize LIPM Planner (e.g., for a humanoid 0.9m tall)\n    planner = LIPMPlanner(com_height_z=0.9)\n\n    # Initial conditions\n    initial_com_x = 0.0\n    initial_com_vx = 0.0\n    step_duration = 0.8 # seconds for one step\n    desired_zmp_x = 0.0 # ZMP at the origin of the current support foot\n\n    print(f\"Planning CoM trajectory for {step_duration}s step with ZMP at {desired_zmp_x}m\")\n\n    times, x_traj, vx_traj, final_x, final_vx = planner.generate_single_step_com(\n        initial_com_x, initial_com_vx, step_duration, desired_zmp_x\n    )\n\n    print(f\"\\nFinal CoM position: {final_x:.3f}m\")\n    print(f\"Final CoM velocity: {final_vx:.3f}m/s\")\n\n    # Plotting the trajectory\n    plt.figure(figsize=(10, 6))\n    plt.plot(times, x_traj, label='CoM X Position')\n    plt.plot(times, vx_traj, label='CoM X Velocity')\n    plt.axhline(y=desired_zmp_x, color='r', linestyle='--', label=f'Desired ZMP X = {desired_zmp_x}m')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Value')\n    plt.title('LIPM CoM Trajectory for a Single Step')\n    plt.grid(True)\n    plt.legend()\n    plt.show()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"step-4-update-setuppy-and-packagexml-for-my_humanoid_planner",children:["Step 4: Update ",(0,a.jsx)(n.code,{children:"setup.py"})," and ",(0,a.jsx)(n.code,{children:"package.xml"})," for ",(0,a.jsx)(n.code,{children:"my_humanoid_planner"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Update ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/my_humanoid_planner/setup.py"})]}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\n\npackage_name = 'my_humanoid_planner'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='your_name',\n    maintainer_email='your_email@example.com',\n    description='TODO: Package description',\n    license='TODO: License declaration',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'run_lipm = my_humanoid_planner.run_lipm_planner:main',\n        ],\n    },\n)\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Update ",(0,a.jsx)(n.code,{children:"~/ros2_ws/src/my_humanoid_planner/package.xml"})]}),":\nAdd these dependencies:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"  <depend>python3-numpy</depend>\n  <depend>python3-matplotlib</depend>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-5-build-your-package-and-run-the-planner",children:"Step 5: Build Your Package and Run the Planner"}),"\n",(0,a.jsx)(n.p,{children:"Navigate back to your workspace root and build your package:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select my_humanoid_planner\n"})}),"\n",(0,a.jsx)(n.p,{children:"Source your workspace:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:". install/setup.bash\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, run the LIPM planner:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ros2 run my_humanoid_planner run_lipm\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will display a plot of the CoM position and velocity over time."}),"\n",(0,a.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The script runs without errors."}),"\n",(0,a.jsx)(n.li,{children:"A plot window appears, showing the CoM position and velocity trajectories."}),"\n",(0,a.jsxs)(n.li,{children:["The CoM position should start at ",(0,a.jsx)(n.code,{children:"0.0"})," and move outwards (or inwards, depending on the initial conditions and ZMP)."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"challenge-questions",children:"Challenge Questions"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Varying ZMP"}),": Modify ",(0,a.jsx)(n.code,{children:"generate_single_step_com"})," to make ",(0,a.jsx)(n.code,{children:"desired_zmp_x"})," a function of time, mimicking a ZMP that moves within the support foot. How does this affect the CoM trajectory?"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Double Support Phase"}),': Extend the planner to include a "double support phase" where both feet are on the ground. How would the ZMP dynamics change, and how would you transition between single and double support?']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Ankle Strategy"}),': In real humanoids, the ankle can apply a small torque to shift the ZMP. How could you incorporate this "ankle strategy" into the LIPM model to achieve a more robust balance?']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"3D LIPM"}),": Extend the model to 3D, controlling both x and y components of the CoM."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var t=s(6540);const a={},i=t.createContext(a);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);