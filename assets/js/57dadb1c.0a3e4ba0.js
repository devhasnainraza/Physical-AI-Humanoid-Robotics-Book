"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[20],{2824:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"module-2-digital-twin/intro","title":"Simulation Theory & Gazebo","description":"1. Why We Simulate: The Reality Gap","source":"@site/docs/module-2-digital-twin/intro.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/intro","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-digital-twin/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Simulation Theory & Gazebo"},"sidebar":"textbookSidebar","previous":{"title":"Modeling Robots with URDF","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/urdf-modeling"},"next":{"title":"Building a Realistic World (SDF)","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/gazebo-world"}}');var s=i(4848),l=i(8453);const r={sidebar_position:1,title:"Simulation Theory & Gazebo"},o="Module 2: The Digital Twin & Simulation Theory",a={},d=[{value:"1. Why We Simulate: The Reality Gap",id:"1-why-we-simulate-the-reality-gap",level:2},{value:"1.1 The Digital Twin",id:"11-the-digital-twin",level:3},{value:"2. Physics Engines: ODE vs Bullet vs PhysX",id:"2-physics-engines-ode-vs-bullet-vs-physx",level:2},{value:"2.1 The Time Step",id:"21-the-time-step",level:3},{value:"3. Gazebo Architecture",id:"3-gazebo-architecture",level:2},{value:"4. Hands-On: Launching an Empty World",id:"4-hands-on-launching-an-empty-world",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"module-2-the-digital-twin--simulation-theory",children:"Module 2: The Digital Twin & Simulation Theory"})}),"\n",(0,s.jsx)(t.h2,{id:"1-why-we-simulate-the-reality-gap",children:"1. Why We Simulate: The Reality Gap"}),"\n",(0,s.jsxs)(t.p,{children:["In Physical AI, the ",(0,s.jsx)(t.strong,{children:"Reality Gap"})," is the discrepancy between how a robot behaves in a simulator versus the real world. If you train a robot to walk on a perfectly flat friction=1.0 surface in a simulation, it will likely fall immediately on real carpet."]}),"\n",(0,s.jsx)(t.h3,{id:"11-the-digital-twin",children:"1.1 The Digital Twin"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"Digital Twin"})," is not just a 3D model; it is a physics-accurate replica that accounts for:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Inertia"}),": The resistance of the robot's limbs to movement."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Friction"}),": Kinetic and static friction coefficients of feet."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Actuator Dynamics"}),": Real motors don't reach target speed instantly; they have torque curves and delays."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"2-physics-engines-ode-vs-bullet-vs-physx",children:"2. Physics Engines: ODE vs Bullet vs PhysX"}),"\n",(0,s.jsx)(t.p,{children:"Gazebo (and Ignition/Gazebo Sim) allows you to choose your underlying physics engine."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Engine"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Pros"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Cons"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Best For"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"ODE (Open Dynamics Engine)"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Stable, default in ROS"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Less accurate for complex contacts"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Wheeled robots, simple arms"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Bullet"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Better collision detection"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Slower than ODE"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Games, object manipulation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"NVIDIA PhysX"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"GPU-accelerated, massive scale"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Proprietary (until recently), requires NVIDIA GPU"}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:"Humanoid RL Training"})," (Isaac Gym)"]})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"21-the-time-step",children:"2.1 The Time Step"}),"\n",(0,s.jsx)(t.p,{children:"Simulations run in discrete time steps (e.g., 1ms)."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Real-time Factor"}),": If ratio < 1.0, the sim is running slower than real life."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hardware-in-the-Loop (HIL)"}),": Connecting the real robot's computer (Jetson) to the simulation PC to test the actual code performance."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"3-gazebo-architecture",children:"3. Gazebo Architecture"}),"\n",(0,s.jsx)(t.p,{children:"Gazebo is split into two main processes:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"gz-server"}),": Runs the physics loop and sensor generation. It has no GUI. You can run this on a headless cloud server (AWS)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"gz-client"}),": The visualization GUI. Connects to the server to render the scene."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-mermaid",children:"graph LR\n    A[ROS 2 Nodes] <--\x3e|ros_gz_bridge| B(Gazebo Server);\n    B --\x3e|Physics Update| B;\n    B --\x3e|Render State| C[Gazebo Client];\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"4-hands-on-launching-an-empty-world",children:"4. Hands-On: Launching an Empty World"}),"\n",(0,s.jsx)(t.p,{children:"To start a basic simulation environment:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'sudo apt install ros-humble-ros-gz\nros2 launch ros_gz_sim gz_sim.launch.py gz_args:="empty.sdf"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This launches the new ",(0,s.jsx)(t.strong,{children:"Gazebo Harmonic"})," (formerly Ignition), which is the standard for ROS 2."]})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var n=i(6540);const s={},l=n.createContext(s);function r(e){const t=n.useContext(l);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(l.Provider,{value:t},e.children)}}}]);