"use strict";(globalThis.webpackChunkcortex_h1=globalThis.webpackChunkcortex_h1||[]).push([[4830],{2191:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-1-ros2/robot-hardware","title":"1.2 Hardware Interfacing","description":"micro-ROS, Serial Communication, and Custom Hardware Interfaces.","source":"@site/docs/module-1-ros2/02-robot-hardware.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/robot-hardware","permalink":"/Cortex-H1/docs/module-1-ros2/robot-hardware","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1-ros2/02-robot-hardware.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"robot-hardware","title":"1.2 Hardware Interfacing","sidebar_label":"1.2 Hardware Interface","description":"micro-ROS, Serial Communication, and Custom Hardware Interfaces."},"sidebar":"textbookSidebar","previous":{"title":"1.1 ROS 2 Foundations","permalink":"/Cortex-H1/docs/module-1-ros2/foundations-physical-ai"},"next":{"title":"1.3 Kinematics (URDF)","permalink":"/Cortex-H1/docs/module-1-ros2/kinematics-dynamics"}}');var i=r(4848),o=r(8453);const t={id:"robot-hardware",title:"1.2 Hardware Interfacing",sidebar_label:"1.2 Hardware Interface",description:"micro-ROS, Serial Communication, and Custom Hardware Interfaces."},l="1.2 Hardware Interfacing in ROS 2",c={},d=[{value:"\ud83c\udfaf Lab Objectives",id:"-lab-objectives",level:2},{value:"1.2.1 The Problem: Real-Time Constraints",id:"121-the-problem-real-time-constraints",level:2},{value:"1.2.2 micro-ROS: ROS on a Chip",id:"122-micro-ros-ros-on-a-chip",level:2},{value:"Hands-On: ESP32 Setup",id:"hands-on-esp32-setup",level:3},{value:"1.2.3 ros2_control Hardware Interface",id:"123-ros2_control-hardware-interface",level:2},{value:"1.2.4 Common Protocols",id:"124-common-protocols",level:2},{value:"1.2.5 Quiz",id:"125-quiz",level:2}];function a(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"12-hardware-interfacing-in-ros-2",children:"1.2 Hardware Interfacing in ROS 2"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"Code meets Metal."'})}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 runs on Linux (your brain). Motors run on Microcontrollers (your spine). This chapter bridges the gap."}),"\n",(0,i.jsx)(n.h2,{id:"-lab-objectives",children:"\ud83c\udfaf Lab Objectives"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Understand the Hardware Interface"}),": The standard way ROS talks to actuators."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"micro-ROS"}),": Running ROS 2 directly on a microcontroller (ESP32/Teensy)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lab"}),": Blink an LED using a ROS Topic."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"121-the-problem-real-time-constraints",children:"1.2.1 The Problem: Real-Time Constraints"}),"\n",(0,i.jsxs)(n.p,{children:["Linux is ",(0,i.jsx)(n.strong,{children:"not real-time"}),". It might pause your code to update Chrome.\nMotors need updates every 1ms (1000Hz).\n",(0,i.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Level"}),": ROS 2 on Jetson/Pi (Planning, Vision)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low Level"}),": C++ on MCU (Motor FOC, Safety Limits)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bridge"}),": Serial/USB/Ethernet."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"122-micro-ros-ros-on-a-chip",children:"1.2.2 micro-ROS: ROS on a Chip"}),"\n",(0,i.jsx)(n.p,{children:"micro-ROS puts a tiny ROS agent on the microcontroller."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Your MCU becomes a ",(0,i.jsx)(n.strong,{children:"First-Class ROS Node"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"It can Publish/Subscribe directly."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hands-on-esp32-setup",children:"Hands-On: ESP32 Setup"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Install the micro-ROS Arduino library"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code (Arduino IDE)"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <micro_ros_arduino.h>\n#include <rcl/rcl.h>\n#include <rcl/error_handling.h>\n#include <rclc/rclc.h>\n#include <rclc/executor.h>\n#include <std_msgs/msg/int32.h>\n\nrcl_publisher_t publisher;\nstd_msgs__msg__Int32 msg;\n\nvoid setup() {\n  set_microros_transports();\n  \n  // Initialize Node\n  rclc_support_t support;\n  rcl_allocator_t allocator = rcl_get_default_allocator();\n  rclc_support_init(&support, 0, NULL, &allocator);\n  \n  rcl_node_t node;\n  rclc_node_init_default(&node, "micro_ros_arduino_node", "", &support);\n  \n  // Create Publisher\n  rclc_publisher_init_default(\n    &publisher,\n    &node,\n    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),\n    "micro_ros_counter");\n}\n\nvoid loop() {\n  msg.data++;\n  rcl_publish(&publisher, &msg, NULL);\n  delay(100);\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run the Agent on PC"}),":\n",(0,i.jsx)(n.code,{children:"docker run -it --rm -v /dev:/dev --privileged --net=host microros/micro-ros-agent:humble serial --dev /dev/ttyUSB0"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": ",(0,i.jsx)(n.code,{children:"ros2 topic echo /micro_ros_counter"})," shows the count!"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"123-ros2_control-hardware-interface",children:"1.2.3 ros2_control Hardware Interface"}),"\n",(0,i.jsxs)(n.p,{children:["For complex robots, we don't just write random publishers. We use the ",(0,i.jsx)(n.code,{children:"SystemInterface"})," C++ API.\nThis allows us to switch between ",(0,i.jsx)(n.strong,{children:"Simulation"})," and ",(0,i.jsx)(n.strong,{children:"Real Hardware"})," without changing a single line of control code."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"read()"}),": Get encoder values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"write()"}),": Send torque commands."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We will cover this deeply in the ",(0,i.jsx)(n.strong,{children:"Control Systems"})," lab."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"124-common-protocols",children:"1.2.4 Common Protocols"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"UART (Serial)"}),": Easy. Slow. Good for debugging."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I2C/SPI"}),": Board level. Connect IMUs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CAN Bus"}),": The gold standard.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Differential Signal"}),": Immune to noise."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Daisy Chain"}),": Connect 12 motors with 2 wires."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SocketCAN"}),": Linux treats CAN like a network interface (",(0,i.jsx)(n.code,{children:"can0"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"125-quiz",children:"1.2.5 Quiz"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why can't we drive motors directly from the Raspberry Pi GPIO?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a) Not enough voltage."}),"\n",(0,i.jsx)(n.li,{children:"b) Linux is not real-time (jitter)."}),"\n",(0,i.jsx)(n.li,{children:"c) Both."}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.em,{children:"Answer: c"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What is the benefit of micro-ROS?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a) It makes the chip faster."}),"\n",(0,i.jsx)(n.li,{children:"b) It allows the MCU to talk ROS natively (Topics/Services) without custom protocols."}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.em,{children:"Answer: b"})}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(6540);const i={},o=s.createContext(i);function t(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);