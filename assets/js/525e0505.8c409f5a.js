"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[7636],{4066:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-ai-brain/navigation-stack","title":"Nav2 Architecture","description":"1. Moving from A to B","source":"@site/docs/module-3-ai-brain/02-navigation-stack.md","sourceDirName":"module-3-ai-brain","slug":"/module-3-ai-brain/navigation-stack","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-brain/navigation-stack","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3-ai-brain/02-navigation-stack.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Nav2 Architecture"},"sidebar":"textbookSidebar","previous":{"title":"The Isaac Ecosystem","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-brain/intro"},"next":{"title":"Visual SLAM","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-brain/visual-slam"}}');var s=r(4848),o=r(8453);const i={sidebar_position:2,title:"Nav2 Architecture"},a="Nav2: The Navigation Stack",l={},c=[{value:"1. Moving from A to B",id:"1-moving-from-a-to-b",level:2},{value:"1.1 The Architecture",id:"11-the-architecture",level:3},{value:"2. A* Algorithm: The Planner&#39;s Core",id:"2-a-algorithm-the-planners-core",level:2},{value:"Pseudocode",id:"pseudocode",level:3},{value:"3. Costmaps: The World Representation",id:"3-costmaps-the-world-representation",level:2},{value:"3.1 Layered Costmaps",id:"31-layered-costmaps",level:3},{value:"4. Behavior Trees (BT)",id:"4-behavior-trees-bt",level:2},{value:"5. MPPI for Humanoids",id:"5-mppi-for-humanoids",level:2}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nav2-the-navigation-stack",children:"Nav2: The Navigation Stack"})}),"\n",(0,s.jsx)(n.h2,{id:"1-moving-from-a-to-b",children:"1. Moving from A to B"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nav2"}),' is the industry-standard navigation framework for ROS 2. It turns a "Goal Pose" (x, y, theta) into motor commands, while avoiding obstacles.']}),"\n",(0,s.jsx)(n.h3,{id:"11-the-architecture",children:"1.1 The Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Nav2 is not a single node; it is a collection of servers managed by a Behavior Tree."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global Planner"}),": Calculates the path from Start to Goal.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Algorithms"}),": Dijkstra, A* (A-Star), Smac Planner (Hybrid A*)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Map"}),": Uses the Static Map (from SLAM)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local Planner (Controller)"}),": Follows the path while avoiding dynamic obstacles (people, dogs).","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Algorithms"}),": DWB (Dynamic Window Approach), MPPI (Model Predictive Path Integral)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Map"}),": Uses the Local Costmap (rolling window)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recoveries (Behaviors)"}),": What to do if stuck.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Examples"}),": Spin in place, back up, clear costmap."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"2-a-algorithm-the-planners-core",children:"2. A* Algorithm: The Planner's Core"}),"\n",(0,s.jsx)(n.p,{children:"A* finds the shortest path by minimizing $f(n) = g(n) + h(n)$."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"$g(n)$: Cost from Start to current node $n$."}),"\n",(0,s.jsx)(n.li,{children:"$h(n)$: Heuristic cost from $n$ to Goal (usually Euclidean distance)."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"open_set = {start_node}\ncame_from = {}\n\ng_score[start] = 0\nf_score[start] = heuristic(start, goal)\n\nwhile open_set is not empty:\n    current = node in open_set with lowest f_score\n    if current == goal:\n        return reconstruct_path(came_from, current)\n\n    open_set.remove(current)\n    \n    for neighbor in neighbors(current):\n        tentative_g = g_score[current] + dist(current, neighbor)\n        if tentative_g < g_score[neighbor]:\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g\n            f_score[neighbor] = tentative_g + heuristic(neighbor, goal)\n            if neighbor not in open_set:\n                open_set.add(neighbor)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In robotics, the cost function also includes the ",(0,s.jsx)(n.strong,{children:"Costmap Value"})," (don't hug the walls!)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"3-costmaps-the-world-representation",children:"3. Costmaps: The World Representation"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"Costmap"})," is a 2D grid where each cell has a value (0-255)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"0"}),": Free space (Safe)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"254"}),": Lethal Obstacle (Wall)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"255"}),": Unknown."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"1-253"}),": Inflation Radius (Danger zone near walls)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"31-layered-costmaps",children:"3.1 Layered Costmaps"}),"\n",(0,s.jsx)(n.p,{children:"The final map is a sum of layers:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Static Layer"}),": The building walls (from SLAM)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Obstacle Layer"}),": Real-time LiDAR hits (People)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inflation Layer"}),": Adds a gradient around obstacles."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Voxel Layer"}),": 3D obstacles (e.g., tables) mapped to 2D."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"4-behavior-trees-bt",children:"4. Behavior Trees (BT)"}),"\n",(0,s.jsxs)(n.p,{children:["Nav2 uses an XML-based ",(0,s.jsx)(n.strong,{children:"Behavior Tree"})," to orchestrate the logic. This is more flexible than a state machine."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Logic:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<root main_tree_to_execute="MainTree">\n  <BehaviorTree ID="MainTree">\n    <RecoveryNode number_of_retries="6">\n      <PipelineSequence name="NavigateWithReplanning">\n        \n        \x3c!-- Every 1s, plan a new path --\x3e\n        <RateController hz="1.0">\n          <ComputePathToPose goal="{goal}" path="{path}"/>\n        </RateController>\n\n        \x3c!-- Follow the path --\x3e\n        <FollowPath path="{path}" controller_id="FollowPath"/>\n        \n      </PipelineSequence>\n\n      \x3c!-- If failed, try to recover --\x3e\n      <Sequence name="RecoveryActions">\n        <ClearEntireCostmap name="ClearLocalCostmap"/>\n        <Spin spin_dist="1.57"/>\n        <Wait wait_duration="5"/>\n      </Sequence>\n      \n    </RecoveryNode>\n  </BehaviorTree>\n</root>\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"5-mppi-for-humanoids",children:"5. MPPI for Humanoids"}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, standard controllers (DWB) often fail because they assume a circular or rectangular footprint that moves smoothly."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MPPI (Model Predictive Path Integral)"})," is a predictive controller that:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Simulates thousands of random trajectories into the future on the GPU."}),"\n",(0,s.jsx)(n.li,{children:"Scores them (low cost = good, hit wall = bad)."}),"\n",(0,s.jsx)(n.li,{children:"Executes the weighted average of the best paths."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"MPPI is robust for erratic movement and is highly recommended for legged robots."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);