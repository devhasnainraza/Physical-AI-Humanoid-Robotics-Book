"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[8301],{4970:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-2-digital-twin/gazebo-world","title":"Building a Realistic World (SDF)","description":"1. The SDF Format","source":"@site/docs/module-2-digital-twin/02-gazebo-world.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/gazebo-world","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/gazebo-world","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-digital-twin/02-gazebo-world.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Building a Realistic World (SDF)"},"sidebar":"textbookSidebar","previous":{"title":"Simulation Theory & Gazebo","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/intro"},"next":{"title":"Simulating Sensors (LiDAR & Depth)","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/sensor-plugins"}}');var s=i(4848),o=i(8453);const a={sidebar_position:2,title:"Building a Realistic World (SDF)"},r="Creating a Realistic Test Environment with SDF",l={},d=[{value:"1. The SDF Format",id:"1-the-sdf-format",level:2},{value:"2. Writing <code>test_world.sdf</code>",id:"2-writing-test_worldsdf",level:2},{value:"2.1 PBR Materials (Physically Based Rendering)",id:"21-pbr-materials-physically-based-rendering",level:3},{value:"3. Adding Obstacles",id:"3-adding-obstacles",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"creating-a-realistic-test-environment-with-sdf",children:"Creating a Realistic Test Environment with SDF"})}),"\n",(0,s.jsx)(n.h2,{id:"1-the-sdf-format",children:"1. The SDF Format"}),"\n",(0,s.jsxs)(n.p,{children:["While URDF describes the ",(0,s.jsx)(n.em,{children:"robot"}),", ",(0,s.jsx)(n.strong,{children:"SDF (Simulation Description Format)"})," describes the ",(0,s.jsx)(n.em,{children:"world"})," and the robot's interaction with it. SDF is more powerful than URDF as it allows for closed-loop chains (loops in robot limbs) and detailed environment settings."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"2-writing-test_worldsdf",children:["2. Writing ",(0,s.jsx)(n.code,{children:"test_world.sdf"})]}),"\n",(0,s.jsx)(n.p,{children:"We will create a world with:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sunlight"}),": Directional light source."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ground Plane"}),": With friction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics"}),": Configuring the step size (1ms)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.8">\n  <world name="humanoid_gym">\n    \n    \x3c!-- Physics: 1000 Hz (1ms step) --\x3e\n    <physics name="1ms" type="ignored">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n\n    \x3c!-- Global Light Source --\x3e\n    <light type="directional" name="sun">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <model name="ground_plane">\n      <static>true</static> \x3c!-- Gravity doesn\'t affect it --\x3e\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          \x3c!-- Friction Friction Friction --\x3e\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu> \x3c!-- Static Friction --\x3e\n                <mu2>1.0</mu2> \x3c!-- Dynamic Friction --\x3e\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          \x3c!-- PBR Material --\x3e\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n            <specular>0.8 0.8 0.8 1</specular>\n            <pbr>\n                <metal>\n                  <albedo_map>materials/textures/concrete_albedo.png</albedo_map>\n                  <normal_map>materials/textures/concrete_normal.png</normal_map>\n                  <roughness_map>materials/textures/concrete_roughness.png</roughness_map>\n                </metal>\n            </pbr>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"21-pbr-materials-physically-based-rendering",children:"2.1 PBR Materials (Physically Based Rendering)"}),"\n",(0,s.jsxs)(n.p,{children:["For VSLAM to work, walls cannot be plain white. They need ",(0,s.jsx)(n.strong,{children:"Texture"}),".\nGazebo supports PBR, which uses multiple maps (Albedo, Normal, Roughness) to simulate how light bounces off surfaces. This creates realistic reflections and shadows that are critical for training vision models."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"3-adding-obstacles",children:"3. Adding Obstacles"}),"\n",(0,s.jsx)(n.p,{children:"To test navigation, we need obstacles. You can add simple primitives directly in the SDF:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<model name="box_obstacle">\n  <pose>2 0 0.5 0 0 0</pose> \x3c!-- 2m in front of robot --\x3e\n  <static>true</static>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>1 1 1</size>\n        </box>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <box>\n          <size>1 1 1</size>\n        </box>\n      </geometry>\n      <material>\n        <ambient>1 0 0 1</ambient> \x3c!-- Red --\x3e\n      </material>\n    </visual>\n  </link>\n</model>\n'})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);